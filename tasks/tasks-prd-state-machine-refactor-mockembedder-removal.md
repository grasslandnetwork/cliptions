## Relevant Files

- `src/facades/block_facade.rs` - Facade for `BlockData` field access and state/business logic.
- `src/facades/participant_facade.rs` - Facade for `Participant` safe field access and logic.
- `src/facades/guess_facade.rs` - Facade for `Guess` safe field access and helpers.
- `src/facades/` - Directory for facades (Rust 2021; no mod.rs required).
- `src/config.rs` - `PathManager` centralized path management facade; integrates with config.
- `src/embedder.rs` - Remove `MockEmbedder`; enforce real `ClipEmbedder` only.
- `src/block_processor.rs` - Migrate to facades; later to unified block/typestate.
- `src/block_engine/state_machine.rs` - Typestate block; integration and future unification.
- `src/types.rs` - Legacy `BlockData`, `Participant`, `Guess`; wrapped by facades, later unified.
- `src/actions/*.rs` - Update to use facades and centralized paths.
- `src/main.rs` - Ensure CLI uses facades and PathManager; remove `--use-mock` options.
- `tests/` - New and updated tests for facades, path manager, struct unification, typestate.

### Notes

- If this project uses Rust, it uses **Rust 2021 Edition**.
- **No `mod.rs` files needed** - Project convention: use directory-based modules without `mod.rs`.
- Unit tests can be placed in the same file as the code they are testing, inside a `#[cfg(test)] mod tests { ... }` block.
- Use `cargo test` to run all tests. To run a specific test, you can use `cargo test <test_name>`.
- **Always include documentation updates** - Any task that adds or changes user-facing functionality (CLI commands, APIs, interfaces) must include a sub-task to update relevant documentation (README.md, help text, etc.).

#### Carried Over (Slice 9: Centralized File Path Management - Incomplete Items)
- [x] Add `dirs` crate (dependency) for cross-platform home directory access
- [ ] Create `PathManager` in `src/config.rs` with `new()` that builds `~/.cliptions/`
- [ ] Ensure creation of `~/.cliptions/{data,miner,validator}` via `create_dir_all`
- [ ] Implement getters:
  - `get_config_path()` -> `~/.cliptions/config.yaml`
  - `get_blocks_path()` -> `~/.cliptions/data/blocks.json`
  - `get_twitter_posts_path()` -> `~/.cliptions/data/twitter_posts.json`
  - `get_scoring_versions_path()` -> `~/.cliptions/data/scoring_versions.json`
  - `get_validator_tweet_cache_path()` -> `~/.cliptions/validator/validator_tweet_cache.json`
  - `get_miner_commitments_path()` -> `~/.cliptions/miner/commitments.json`
  - `get_validator_collected_commitments_path()` -> `~/.cliptions/validator/collected_commitments.json`
  - `get_validator_collected_reveals_path()` -> `~/.cliptions/validator/collected_reveals.json`
- [ ] Integrate `PathManager` with `ConfigManager::new()` and `with_path()`
- [ ] Replace hardcoded paths throughout codebase with `PathManager` getters
- [ ] Clear error message when `~/.cliptions/config.yaml` missing
- [ ] Update README and docs for new locations under `~/.cliptions`
- [ ] Unit tests for `PathManager` (path generation and directory creation)

## Tasks

- [ ] 1.0 Implement Comprehensive Facades for `BlockData`, `Participant`, `Guess`, and `Block<S>`
  - [x] 1.1 Create `src/facades/` with `block_facade.rs`, `participant_facade.rs`, `guess_facade.rs`
  - [x] 1.2 Define `trait BlockFacade` with stable accessors (e.g., `block_id()`, `block_num()`, `prize_pool()`, state queries)
  - [x] 1.3 Implement `BlockFacade` for `BlockData` (map fields, including legacy differences)
  - [x] 1.4 Implement `BlockFacade` for `Block<S>` (map fields via typestate; start at `CommitmentsOpen`)
  - [x] 1.5 Implement `ParticipantFacade` (getters: `social_id`, `username`, `guess()`, `wallet`, `score`, `is_verified()`)
  - [x] 1.6 Implement `GuessFacade` (getters: `text`, `timestamp`, `has_embedding()`, helper `get_embedding_array()`)
  - [x] 1.7 Replace direct field access across codebase to use facades (search-and-replace guided edits)
  - [ ] 1.8 Add unit tests for each facade; verify no `struct.field` access in consumers (deferred)
  - [ ] 1.9 Update docs to describe facade usage and field access policy (deferred)

- [ ] 2.0 Centralized Path Management (Carryover from Slice 9)
  - [x] 2.1 Add `dirs` crate dependency
  - [x] 2.2 Implement `PathManager::new()` in `src/config.rs` to prepare `~/.cliptions/` structure
  - [x] 2.3 Implement getters: config, blocks, twitter_posts, scoring_versions, validator_tweet_cache, miner_commitments, validator_collected_commitments, validator_collected_reveals
  - [x] 2.4 Replace all hardcoded paths with `PathManager` getters
  - [x] 2.5 Integrate `PathManager` with `ConfigManager::{new, with_path}`
  - [x] 2.6 Clear error message when `~/.cliptions/config.yaml` missing
  - [ ] 2.7 Unit tests for `PathManager` (path generation, directory creation) (deferred)
  - [ ] 2.8 Update README/docs for new default locations (deferred)

- [ ] 3.0 Remove MockEmbedder and Enforce Real CLIP Model Everywhere
  - [x] 3.1 Delete `MockEmbedder` from `src/embedder.rs`; remove re-exports from `src/lib.rs`
  - [x] 3.2 Remove `--use-mock` flags and logic from CLI binaries and actions
  - [x] 3.3 Update `BlockProcessor` and scoring to use `ClipEmbedder` only; adjust generics if needed
  - [x] 3.4 Update `python_bridge.rs`, `benches/`, and tests to use real embeddings
  - [x] 3.5 Ensure startup/model load fails fast with clear panic if CLIP model unavailable
  - [x] 3.6 Update README and CLI help to remove mock references

- [ ] 4.0 Unify `BlockData` and `Block<S>` into a Single Typestate-Ready Struct
  - [x] 4.1 Design unified `Block<S>` struct (use `block_num`, not `block_id`)
  - [x] 4.2 Implement DTO conversions for JSON compatibility (legacy `BlockData` ↔ unified `Block<S>`)
  - [x] 4.3 Implement `BlockFacade` for unified struct; keep facade API stable
  - [x] 4.4 Migrate consumers (processors, actions, CLI) to unified struct via facades (reads via facade across `BlockProcessor`, `calculate_scores`, `verify_commitments`; storage swap next)
  - [ ] 4.5 Remove legacy `BlockData` after migration and tests are green
  - [x] 4.6 Add/adjust tests for unified struct and DTO mappings

- [ ] 5.0 Implement Full Typestate Pattern and DTO Layer; Update Twitter Integration
  - [x] 5.1 Implement typestate transitions in unified struct starting at `CommitmentsOpen` (no `Pending`)
  - [x] 5.2 Update state parsing/DTO mapping; map any legacy `Pending` to `CommitmentsOpen`
    - Added unit tests to ensure conversion From<&BlockData> yields `CommitmentsOpen` as the entry state
  - Prototype guardrails (apply to all 5.x):
    - Use owned types (`String`, `Vec`, `PathBuf`, `f64`); avoid lifetimes and generics until clearly needed
    - Prefer concrete structs over traits; introduce traits only after duplication becomes painful
    - Use `todo!()`, `unreachable!()`, `assert!()`, `dbg!()` while iterating; clean up later
    - Use `anyhow::Result<T>` with `with_context`/`bail!` for quick error handling
    - Keep modules flat where possible; colocate unit tests via `#[cfg(test)]`
    - Defer optimization; write clear, deterministic tests and scaffolding
    - Centralize DTO/back-compat; keep `BlockFacade` API stable for consumers
  - [ ] 5.3 Consolidate block data into typestate `Block<S>`
    - [x] 5.3.1 Add fields to `Block<S>` in `src/block_engine/state_machine.rs` to subsume client-side needs
      - `participants: Vec<Participant>`
      - `prize_pool: f64`
      - `total_payout: f64` (derived but stored for JSON compatibility)
      - Use owned types; avoid lifetimes/generics in this slice
    - [x] 5.3.2 Update `impl From<&BlockData> for Block<CommitmentsOpen>` to map new fields
      - participants/prize pool → carried over
      - target image path → `target_frame_path`
      - Keep mapping simple; use `serde(default)` where needed
    - [x] 5.3.3 Update `to_legacy_with_template(&self, template: &BlockData)` to round‑trip new fields
      - Single DTO round‑trip point; copy fields verbatim to preserve compatibility
    - [x] 5.3.4 Update `impl BlockFacade for TypedBlock<S>` to return real values for `participants_len`, `verified_participants_len`, `prize_pool`, `total_payout`, `is_complete`
      - Return direct values; avoid introducing extra traits/abstractions here
    - [x] 5.3.5 Add unit tests for DTO round‑trip and facade values
      - Ensure counts, prize pool, and total payout survive serialize/deserialize
      - Ensure `status()` mapping remains stable across states
      - Colocate tests; deterministic fixtures; use `anyhow` in helpers; `unwrap` acceptable in tests
    - Notes: Follow the typestate design guidelines from [The Typestate Pattern in Rust](https://cliffle.com/blog/rust-typestate/)
  - [ ] 5.4 Introduce storage abstraction used by typestate flows
    - [x] 5.4.1 Define `trait BlockStore` in `src/block_engine/store.rs`
      - `fn load_commitments_open(&self, num: &str) -> Result<Block<CommitmentsOpen>>`
      - `fn load_any<S: StateMarker>(&self, num: &str) -> Result<Block<S>>`
      - `fn save<S: StateMarker>(&self, block: &Block<S>) -> Result<()>`
      - `fn list(&self) -> Result<Vec<String>>`
      - Keep trait minimal; prefer a concrete store API first if simpler
    - [x] 5.4.2 Implement `JsonBlockStore` backed by `~/.cliptions/data/blocks.json` via `PathManager`
      - Use `serde_json` with a `BTreeMap<String, serde_json::Value>` to preserve unknown fields
      - Ensure safe concurrent updates by read‑modify‑write on a per‑block value
      - Use `anyhow::Result`; naive read‑modify‑write is fine; no concurrency primitives yet
    - [x] 5.4.3 Auto‑persist at safe transition boundaries
      - Each public transition method that consumes `self` returns the next state; callers save explicitly
      - Provide helper `save_after(self, store: &impl BlockStore) -> Result<Block<Next>>` patterns only if duplication appears
    - [x] 5.4.4 Tests
      - Load/save round‑trip preserves fields and state
      - `list()` returns existing keys even with mixed legacy/unified blocks
      - Use temp dirs; `unwrap`/`expect` acceptable in tests
  - [ ] 5.5 Participant and commitment operations in typestate
    - [x] 5.5.1 In `impl Block<CommitmentsOpen>` add:
      - `fn add_participant(&mut self, p: Participant)`
      - `fn verify_commitments(&mut self, verifier: &CommitmentVerifier) -> usize` (marks `verified`)
    - [x] 5.5.2 Tests
      - Adding/verification updates counts; only participants with valid salts/hashes are marked verified
      - Use `&mut self`; keep signatures concrete; assert invariants with `assert!`/`debug_assert!`
  - [ ] 5.6 Reveal and payout flows in typestate
    - [x] 5.6.1 `impl Block<CommitmentsClosed>::capture_frame(PathBuf) -> Result<Block<FrameCaptured>>` (already present)
    - [x] 5.6.2 `impl Block<FrameCaptured>::open_reveals(...) -> Result<Block<RevealsOpen>>` (already present)
    - [x] 5.6.3 `impl Block<RevealsOpen>::close_reveals(...) -> Result<Block<RevealsClosed>>`
    - [x] 5.6.4 `impl Block<RevealsClosed>::begin_payouts(self) -> Block<Payouts>`
    - [x] 5.6.5 `impl Block<Payouts>::process_payouts(self, embedder: &ClipEmbedder, strategy: &impl ScoringStrategy) -> Result<Block<Finished>>`
      - Compute embeddings, scores, ranks, payouts; accumulate `total_payout`; set final status
    - [ ] 5.6.6 Tests
      - Happy path through Payouts to Finished with deterministic scaffolding
    - Notes: Start with skeleton transitions; use `todo!()` where appropriate, then fill in happy path. Pass `ClipEmbedder` directly; compute totals via straightforward accumulation
  - [ ] 5.7 Update actions/CLI to use typestate + BlockStore (remove `BlockProcessor` usage)
    - Verification de-dup plan: unify verification on typestate `Block<CommitmentsOpen>::verify_commitments` + `JsonBlockStore`; deprecate legacy `BlockProcessor` path and direct JSON writes
    - [x] 5.7.1 `calculate_scores`: load → advance to `Payouts` → `process_payouts` → save → display
    - [x] 5.7.2 `verify_commitments` (actions):
      - [x] 5.7.2.1 Load block via `JsonBlockStore::load_commitments_open`
      - [x] 5.7.2.2 Upsert participants from collected commitments/reveals (by `social_id`)
      - [x] 5.7.2.3 Call `Block<CommitmentsOpen>::verify_commitments(&CommitmentVerifier)` and `store.save(&block)`
      - [x] 5.7.2.4 Remove/replace `save_to_blocks_json` with store-mediated save
      - [x] 5.7.2.5 Display counts from the updated block; preserve existing output semantics
    - [x] 5.7.3 `post_target_frame`: ensure it calls `open_reveals` with proper parent tweet
    - [x] 5.7.4 Update any remaining actions to operate via typestate transitions
    - Notes: Use `anyhow` in actions/CLI; keep functions concrete; initial `unwrap` acceptable for CLI
  - [ ] 5.8 Batch operations and stats via typestate
    - [ ] 5.8.1 Provide a small helper `process_all(store: &impl BlockStore)` that iterates `list()` and advances eligible blocks
    - [ ] 5.8.2 Add `fn stats(&self) -> BlockStats` on `Block<Finished>` (and minimal variants for other states if needed)
    - [ ] 5.8.3 Replace `BlockProcessor::get_block_stats` callers with typestate stats
    - Notes: Implement with plain loops; no async/concurrency; `BlockStats` as a simple struct
  - [ ] 5.9 Remove `BlockProcessor`
    - [ ] 5.9.1 Delete `src/block_processor.rs`; remove imports/usages; adapt tests to typestate/store
    - [ ] 5.9.2 Replace JSON mutations in actions with store‑mediated saves
    - [ ] 5.9.3 Ensure all previous `blocks.json` fields remain backward compatible via DTO layer
  - [ ] 5.10 Ensure `AnnouncementFormatter` and Twitter posting align with new states
    - [ ] 5.10.1 Validate copy and state names for all transitions; unify casing and hashtags
    - [ ] 5.10.2 Add tests around formatter text and reply‑with‑image pathways
    - Notes: Build strings with owned `String`; keep formatting minimal; tests focus on stable copy
  - [ ] 5.11 Comprehensive tests and docs
    - [ ] 5.11.1 Add state transition tests enforcing compile‑time validity and runtime preconditions
    - [ ] 5.11.2 Add storage round‑trip and migration tests for legacy `blocks.json`
    - [ ] 5.11.3 Add comments in code to describe the typestate lifecycle and operations
    - [ ] 5.11.4 Document extension points (`BlockStore`, scoring strategy) and invariants
    - Notes: Colocate unit tests with code; keep fixtures deterministic; update docs when CLI/UI behavior changes

